from concurrent import futures
import sys
import grpc
import socket
import threading
import logging
import server_pb2
import server_pb2_grpc
import centralServer_pb2
import centralServer_pb2_grpc

# its a subclass of the serverServicer class, which is the class generated by the compiler
class Server(server_pb2_grpc.serverServicer):
    def __init__(self, stop_event, flag = False):
        
        self.flag = flag # flag to check if the server is expected to communicate with the central server
        self.pairs = dict() # dictionary to store the pairs (key, value)
        self.ID = f"{socket.getfqdn()}:{sys.argv[1]}" # ID of the server
        self._stop_event = stop_event # stop event to terminate the server
        
    def insert(self, request, context):
        
        """
        ● insert - receives as parameters a positive integer (key) and a string (value) and
        ---------  inserts the pair (key, value) in the server, returning 0 if successful, -1 if the key
                   already exists;

        """
        
        key = request.key
        value = request.value
        if key in self.pairs:
            return server_pb2.insertResponse(success = -1)
        else:
            self.pairs[key] = value
            return server_pb2.insertResponse(success = 0) 
    
    def consult(self, request, context):
        
        """
            
            ● consult - receives as parameter a positive integer (key) and returns the string
            ---------   content associated with the key, if it exists, or an empty string otherwise;

        """
        
        key = int(request.key)
        if key in self.pairs:
            return server_pb2.consultResponse(value = self.pairs[key])
        else:
            return server_pb2.consultResponse(value = "")
        
    def activate(self, request, context):
        
        """ 

            ● activate - receives as parameter the ID of the central server and returns the
            ----------   number of keys that were activated (i.e., that were not already active); if
                         the service is not active, it returns 0;
        """
        
        if not self.flag:
            return server_pb2.activateResponse(amountOfActivatedKeys = 0)
        else:
            channel = grpc.insecure_channel(request.centralServerID) # request.centralServerID is the ID of the central server
            stub = centralServer_pb2_grpc.centralServerStub(channel) # stub is the object with references to the remote procedures
            response = stub.register(centralServer_pb2.registerRequest(serverID = str(self.ID), keyList = list(self.pairs.keys()))) # request to the central server
            return server_pb2.activateResponse(amountOfActivatedKeys = int(response.amountOfRegisteredKeys)) # response from the central server
    
    def terminate(self, request, context):
        
        """

            ● terminate - terminates the server, returning the number of keys that were
            -----------   active at the time of termination;
        
        """
        
        self._stop_event.set() # set the stop event
        return server_pb2.terminateResponse(key = 0) # return the number of keys that were active at the time of termination
    
def run():
    # create the stop event, this is used to terminate the server after the client sends the terminate command
    stop_event = threading.Event()
    
    # create the server
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    
    # if the server is expected to communicate with the central server
    if len(sys.argv) == 3:
        # add the serverServicer to the server with the flag set to True
        server_pb2_grpc.add_serverServicer_to_server(Server(stop_event, flag = True), server)
    else:
        # add the serverServicer to the server without the flag(=False)
        server_pb2_grpc.add_serverServicer_to_server(Server(stop_event), server)
        
    # set to default host
    host = "0.0.0.0"
    
    # get the port from the command line
    port = sys.argv[1]
    
    # add the insecure port to the server
    server.add_insecure_port(f"{host}:{port}")
    
    # start the server
    server.start()
    
    # wait for the stop event
    stop_event.wait()
    
    # wait 1 second(so the message can be send to the client before it terminates) and stop the server
    server.stop(1)
    
if __name__ == "__main__":
    logging.basicConfig()
    run()
        