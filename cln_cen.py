from concurrent import futures
import sys
import grpc
import socket
from proto import centralServer_pb2 as centralMessages
from proto import centralServer_pb2_grpc as centralServices
from proto import server_pb2 as messages
from proto  import server_pb2_grpc as services

def run():
    # open a channel to the central server
    channel = grpc.insecure_channel(f"{sys.argv[1]}")
    
    # create the stub, which will be the object with references to the remote procedures
    # (code generated by the compiler)
    stub = centralServices.centralServerStub(channel)
    
    while True:
        # read the input from the client
        try:
            clientInput  = input().split(",", maxsplit = 2)
        except EOFError:
            break
        command = clientInput[0]
        
        if command == "C":
            
            """
                
                ● C,ch - executes the server mapping method in search of the key ch;
                --------  if the answer is an empty string, it does not write anything; otherwise, write the
                          response string, followed by ":", execute a query type RPC for the
                          server that was identified in the mapping response and write the return value (which can be an empty string).

            """
            
            key = clientInput[1] # key to be searched
            response = stub.map(centralMessages.mapRequest(key = int(key))) # request to the central server
            serverID = response.serverID # serverID that has the key
            if serverID != "": # if the serverID is not empty, the client will send a request to the server
                print(f"{str(serverID)}", end=':')
                channelServer = grpc.insecure_channel(serverID) # open a channel to the server
                stubServer = services.serverStub(channelServer) # create the stub, which will be the object with references to the remote procedures
                response = stubServer.consult(messages.consultRequest(key = int(key))) # request to the server
                print(f"{str(response.value)}")
                
        elif command == "T":
            
            """
            
                ● T - triggers the server termination operation, writes the return value to the output
                ----  and ends the client.
                
            """
            
            response = stub.terminate(centralMessages.Empty()) # request to the central server
            print(str(response.amountOfRegisteredKeys))
            break
        
    # at the end the client can close the channel to the server.    
    channel.close() 
    
if __name__ == '__main__':
    run()